
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-unit-test using AI Type  and AI Model

ROOST_METHOD_HASH=verifyDevice_b0b8202f56
ROOST_METHOD_SIG_HASH=verifyDevice_b15cfaacd6

"""
Scenario 1: Test successful verification of a new device
Details:
  TestName: testSuccessfulVerificationOfNewDevice
  Description: This test will ensure that the verifyDevice method correctly identifies a new device and saves its metadata successfully.
Execution:
  Arrange: Create a User object and HttpServletRequest mock with necessary details. There should be no existing DeviceMetadata for this user.
  Act: Invoke the verifyDevice method with the created User object and HttpServletRequest.
  Assert: Check that the deviceMetadataRepository's save method was called once with a DeviceMetadata object that has the same details as the ones extracted from the request.
Validation:
  This verifies that the method correctly identifies a new device and saves its metadata. This is important for tracking user device history and for security alerts.

Scenario 2: Test successful verification of an existing device
Details:
  TestName: testSuccessfulVerificationOfExistingDevice
  Description: This test will ensure that the verifyDevice method correctly identifies an existing device and updates its last logged in time.
Execution:
  Arrange: Create a User object and HttpServletRequest mock with necessary details. There should be an existing DeviceMetadata for this user with the same device details and location.
  Act: Invoke the verifyDevice method with the created User object and HttpServletRequest.
  Assert: Check that the deviceMetadataRepository's save method was called once with the existing DeviceMetadata, and its lastLoggedIn field has been updated.
Validation:
  This verifies that the method correctly identifies an existing device and updates its last logged in time. This is important for tracking user device usage.

Scenario 3: Test notification sending for a new device
Details:
  TestName: testNotificationSendingForNewDevice
  Description: This test will ensure that the verifyDevice method sends a notification when encountering a new device.
Execution:
  Arrange: Create a User object and HttpServletRequest mock with necessary details. There should be no existing DeviceMetadata for this user.
  Act: Invoke the verifyDevice method with the created User object and HttpServletRequest.
  Assert: Check that the unknownDeviceNotification method was called once with the correct parameters.
Validation:
  This verifies that the method sends a notification when a new device is used. This is important for alerting the user of potentially unauthorized activity.

Scenario 4: Test correct extraction of IP and device details
Details:
  TestName: testCorrectExtractionOfIpAndDeviceDetails
  Description: This test will ensure that the verifyDevice method correctly extracts the IP and device details from the request.
Execution:
  Arrange: Create a User object and HttpServletRequest mock with necessary details.
  Act: Invoke the verifyDevice method with the created User object and HttpServletRequest.
  Assert: Check that the extractIp and getDeviceDetails methods were each called once and returned the correct values.
Validation:
  This verifies that the method correctly extracts the necessary information from the request. This is essential for identifying the device.

Scenario 5: Test correct handling of GeoIp2Exception
Details:
  TestName: testHandlingOfGeoIp2Exception
  Description: This test will ensure that the verifyDevice method correctly handles a GeoIp2Exception thrown when trying to get the IP location.
Execution:
  Arrange: Create a User object and HttpServletRequest mock with necessary details. The getIpLocation method should be set to throw a GeoIp2Exception.
  Act: Invoke the verifyDevice method with the created User object and HttpServletRequest.
  Assert: Check that the GeoIp2Exception was caught and handled correctly, without interrupting the rest of the method.
Validation:
  This verifies that the method can handle exceptions thrown when trying to get the IP location. This is important for robustness and error handling.
"""
*/

// ********RoostGPT********

package com.baeldung.service;

import com.baeldung.persistence.dao.DeviceMetadataRepository;
import com.baeldung.persistence.model.DeviceMetadata;
import com.baeldung.persistence.model.User;
import com.maxmind.geoip2.DatabaseReader;
import com.maxmind.geoip2.exception.GeoIp2Exception;
import com.maxmind.geoip2.model.CityResponse;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.MessageSource;
import org.springframework.mail.javamail.JavaMailSender;
import ua_parser.Client;
import ua_parser.Parser;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.net.InetAddress;
import java.util.Date;
import java.util.Locale;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import com.google.common.base.Strings;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.NoSuchMessageException;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.stereotype.Component;
import jakarta.servlet.http.HttpServletRequest;
import java.util.*;
import static java.util.Objects.nonNull;

@ExtendWith(MockitoExtension.class)
public class DeviceServiceVerifyDeviceTest {

	@Mock
	DeviceMetadataRepository deviceMetadataRepository;

	@Mock
	DatabaseReader databaseReader;

	@Mock
	Parser parser;

	@Mock
	JavaMailSender mailSender;

	@Mock
	MessageSource messages;

	@InjectMocks
	DeviceService deviceService;

	@Test
	@Tag("valid")
	public void testSuccessfulVerificationOfNewDevice() throws IOException, GeoIp2Exception {
		HttpServletRequest request = mock(HttpServletRequest.class);
		User user = new User();
		user.setId(1L);
		DeviceMetadata deviceMetadata = new DeviceMetadata();
		when(request.getHeader("user-agent")).thenReturn("Mozilla/5.0");
		when(request.getRemoteAddr()).thenReturn("192.168.1.1");
		when(deviceMetadataRepository.findByUserId(user.getId())).thenReturn(null);
		deviceService.verifyDevice(user, request);
		verify(deviceMetadataRepository, times(1)).save(any(DeviceMetadata.class));
	}

	@Test
	@Tag("valid")
	public void testSuccessfulVerificationOfExistingDevice() throws IOException, GeoIp2Exception {
		HttpServletRequest request = mock(HttpServletRequest.class);
		User user = new User();
		user.setId(1L);
		DeviceMetadata deviceMetadata = new DeviceMetadata();
		deviceMetadata.setUserId(user.getId());
		when(request.getHeader("user-agent")).thenReturn("Mozilla/5.0");
		when(request.getRemoteAddr()).thenReturn("192.168.1.1");
		when(deviceMetadataRepository.findByUserId(user.getId())).thenReturn(deviceMetadata);
		deviceService.verifyDevice(user, request);
		verify(deviceMetadataRepository, times(1)).save(deviceMetadata);
	}

	@Test
	@Tag("valid")
	public void testNotificationSendingForNewDevice() throws IOException, GeoIp2Exception {
		HttpServletRequest request = mock(HttpServletRequest.class);
		User user = new User();
		user.setId(1L);
		when(request.getHeader("user-agent")).thenReturn("Mozilla/5.0");
		when(request.getRemoteAddr()).thenReturn("192.168.1.1");
		when(deviceMetadataRepository.findByUserId(user.getId())).thenReturn(null);
		deviceService.verifyDevice(user, request);
		verify(mailSender, times(1)).send(any(SimpleMailMessage.class));
	}

	@Test
	@Tag("valid")
	public void testCorrectExtractionOfIpAndDeviceDetails() throws IOException, GeoIp2Exception {
		HttpServletRequest request = mock(HttpServletRequest.class);
		User user = new User();
		user.setId(1L);
		DeviceMetadata deviceMetadata = new DeviceMetadata();
		when(request.getHeader("user-agent")).thenReturn("Mozilla/5.0");
		when(request.getRemoteAddr()).thenReturn("192.168.1.1");
		when(deviceMetadataRepository.findByUserId(user.getId())).thenReturn(null);
		deviceService.verifyDevice(user, request);
		verify(request, times(1)).getHeader("user-agent");
		verify(request, times(1)).getRemoteAddr();
	}

	@Test
	@Tag("invalid")
	public void testHandlingOfGeoIp2Exception() throws IOException, GeoIp2Exception {
		HttpServletRequest request = mock(HttpServletRequest.class);
		User user = new User();
		user.setId(1L);
		DeviceMetadata deviceMetadata = new DeviceMetadata();
		when(request.getHeader("user-agent")).thenReturn("Mozilla/5.0");
		when(request.getRemoteAddr()).thenReturn("192.168.1.1");
		when(databaseReader.city(InetAddress.getByName(request.getRemoteAddr()))).thenThrow(GeoIp2Exception.class);
		when(deviceMetadataRepository.findByUserId(user.getId())).thenReturn(null);
		deviceService.verifyDevice(user, request);
		verify(databaseReader, times(1)).city(InetAddress.getByName(request.getRemoteAddr()));
		verify(deviceMetadataRepository, times(1)).save(any(DeviceMetadata.class));
	}

}